# 3 术语和定义 ![![intro.defs]!]! {#title}

本文为博主原创文章，未经博主允许不得转载。

------------------------------------------------

^1^ 由于本文档的目的，ISO/IEC 2382-1:1993中给出的术语和定义，ISO 80000-2:2009中给出的术语、定义和符号，以及下列内容被运用。
^2^ ISO和IEC在以下地址维护术语数据库用于标准化：
^(2.1)^ ——IEC在线电工词汇：http://www.electropedia.org/
^(2.2)^ ——ISO在线浏览平台：http://www.iso.org/obp
^3^ 第[20.3](c20#s3)节定义了仅在第[20](c20)至[33](c33)章和附录[D](a3)中使用的附加术语。
^4^ 仅在文档的一小部分中使用的术语被定义在使用它们的地方，并在它们被定义的地方用斜体表示。

------------------------------------------------

## 3.1 访问 ![![defns.access]!]! {#s1}
!<!执行时动作!>! 读取或修改对象的值

------------------------------------------------

## 3.2 实参 ![![defns.argument]!]! {#s2}
!<!函数调用表达式!>! 由括号限定的逗号分隔表中的表达式（[8.2.2](c8#s2.2)）

------------------------------------------------

## 3.3 实参 ![![defns.argument.macro]!]! {#s3}
!<!函数类似宏!>! 括号内逗号分隔列表中的预处理标记序列（[19.3](c19#s3)）

------------------------------------------------

## 3.4 实参 ![![defns.argument.throw]!]! {#s4}
!<!抛出表达式!>! `throw`的操作量（[8.17](c8#s17)）

------------------------------------------------

## 3.5 实参 ![![defns.argument.templ]!]! {#s5}
!<!模板实例化!>! 由角括号限定的逗号分隔列表中的 *常量表达式*、*类型ID* 或 *ID表达式*（[17.3](c17#s3)）

------------------------------------------------

## 3.6 阻塞 ![![defns.block]!]! {#s6}
阻塞执行线程在它越过阻塞操作可以继续执行前，正在等待某些条件（不让实现执行其执行步骤）成立

------------------------------------------------

## 3.7 条件性支持 ![![defns.cond.supp]!]! {#s7}
实现不需要支持的程序构造
【*注：* 每个实现用文档记录不支持的所有条件性支持的构造。*——注结束*】

------------------------------------------------

## 3.8 诊断消息 ![![defns.diagnostic]!]! {#s8}
属于实现定义的实现的输出消息的子集的消息

------------------------------------------------

## 3.9 动态类型 ![![defns.dynamic.type]!]! {#s9}
!<!广义左值!>! 广义左值引用的最深派生对象（[4.5](c4#s5)）的类型
【*例：* 如果指针（[11.3.1](c11#s3.1)）`p`的静态类型是“类`B`的指针”，且指向从`B`派生的类`D`对象（第[13](c13)章），则表达式`*p`的动态类型是“`D`”。引用（[11.3.2](c11#s3.2)）被相似对待。*——例结束*】

------------------------------------------------

## 3.10 动态类型 ![![defns.dynamic.type.prvalue]!]! {#s10}
!<!纯右值!>! 纯右值表达式的静态类型

------------------------------------------------

## 3.11 非法程序 ![![defns.ill.formed]!]! {#s11}
不合法（[3.29](#s29)）的程序

------------------------------------------------

## 3.12 实现定义行为 ![![defns.impl.defined]!]! {#s12}
对于合法程序构造和正确数据，取决于实现和每个实现文档的行为

------------------------------------------------

## 3.13 实现限制 ![![defns.impl.limits]!]! {#s13}
实现对程序的限制

------------------------------------------------

## 3.14 区域特定行为 ![![defns.locale.specific]!]! {#s14}
取决于国籍、文化和语言的区域惯例的每个实现用文档记录的行为

------------------------------------------------

## 3.15 多字节字符 ![![defns.multibyte]!]! {#s15}
表示源码或执行环境的扩展字符集成员的一个或多个字节的序列
【*注：* 扩展字符集是基本字符集（[5.3](c5#s3)）的超集。*——注结束*】

------------------------------------------------

## 3.16 形参 ![![defns.parameter]!]! {#s16}
!<!函数或抓住子句!>! 声明为函数声明或定义的一部分，或在异常处理的抓住子句中获取对函数或句柄的条目的值的对象或引用

------------------------------------------------

## 3.17 形参 ![![defns.parameter.macro]!]! {#s17}
!<!函数类似宏!>! 紧跟宏名称后由括号包围的逗号分隔列表中的标识符

------------------------------------------------

## 3.18 形参 ![![defns.parameter.templ]!]! {#s18}
!<!模板!>! *模板形参列表* 的成员

------------------------------------------------

## 3.19 签名 ![![defns.signature]!]! {#s19}
!<!函数!>! 名称、形参类型列表（[11.3.5](c11#s3.5)）和封闭命名空间（如果有的话）
【*注：* 签名被用作编码和链接的基础。*——注结束*】

------------------------------------------------

## 3.20 签名 ![![defns.signature.templ]!]! {#s20}
!<!函数模板!>! 名称、形参类型列表（[11.3.5](c11#s3.5)）、封闭命名空间（如果有的话）、返回类型和模板形参列表

------------------------------------------------

## 3.21 签名 ![![defns.signature.spec]!]! {#s21}
!<!函数模板特化!>! 模板特化和模板实参（显式指定或推导）的签名

------------------------------------------------

## 3.22 签名 ![![defns.signature.member]!]! {#s22}
!<!类成员函数!>! 名称、形参类型列表（[11.3.5](c11#s3.5)）、函数为成员的类、*常量易变* 限定符（如果有的话）和 *引用限定符*（如果有的话）

------------------------------------------------

## 3.23 签名 ![![defns.signature.member.templ]!]! {#s23}
!<!类成员函数模板!>! 名称、形参类型列表（[11.3.5](c11#s3.5)）、函数为成员的类、*常量易变* 限定符（如果有的话）、*引用限定符*（如果有的话）、返回类型（如果有的话）和模板形参列表

------------------------------------------------

## 3.24 签名 ![![defns.signature.member.spec]!]! {#s24}
!<!类成员函数模板特化!>! 成员函数模板特化和模板实参（显式指定或推导）的签名

------------------------------------------------

## 3.25 静态类型 ![![defns.static.type]!]! {#s25}
不考虑执行语义时由程序分析产生的表达式（[6.9](c6#s9)）类型
【*注：* 表达式的静态类型仅取决于表达式在程序中出现的形式，并且在程序执行时不会改变。*——注结束*】

------------------------------------------------

## 3.26 疏通 ![![defns.unblock]!]! {#s26}
满足一个或多个阻塞执行线程正在等待的条件

------------------------------------------------

## 3.27 未定义行为 ![![defns.undefined]!]! {#s27}
本国际标准没有规定的行为
【*注：* 当本国际标准省略行为的任何明确定义，或程序使用错误构造或错误数据时，可能会出现未定义行为。允许的未定义行为范围从完全忽略不可预测的结果的情况，到在翻译或程序执行过程中以文档中的记录表现环境特征（有或没有发出诊断消息），到终止翻译或执行（发出诊断消息）。许多错误的程序构造不会产生未定义行为；它们需要被诊断。常量表达式的求值永远不会表现出显式指定为未定义的行为（[8.20](c8#s20)）。*——注结束*】

------------------------------------------------

## 3.28 未明确行为 ![![defns.unspecified]!]! {#s28}
对于一个良好的程序构造和正确的数据，取决于实现的行为
【*注：* 不需要实现用文档记录哪些行为发生。可能的行为范围通常由本国际标准划定。*——注结束*】

------------------------------------------------

## 3.29 合法程序 ![![defns.well.formed]!]! {#s29}
根据语法规则、可诊断语义规则和一个定义规则（[6.2](c6#s2)）构造的C++程序
