# 4 总则 ![![intro]!]! {#title}

本文为博主原创文章，未经博主允许不得转载。

------------------------------------------------

## 4.1 实现依从性 ![![intro.compliance]!]! {#s1}
^1^ *可诊断规则* 的集合由本标准中的所有句法和语义规则组成，包含明确标记的“不要求诊断”或描述为“未定义行为”的规则除外。
^2^ 虽然本国际标准只对C++实现提出了要求，但如果这些要求被表述为程序、程序片段或程序执行的要求，那么这些要求通常更容易理解。这种要求具有以下含义：
^(2.1)^ ——如果一个程序不违反本标准中的规则，一致的实现应在其资源范围内接受并正确执行[^2]该程序。
^(2.2)^ ——如果程序包含违反任何可诊断规则或在本标准中描述为“有条件支持”的构造发生，当实现不支持该构造时，一致的实现应发出至少一个诊断消息。
^(2.3)^ ——如果程序包含违反不要求诊断的规则，本国际标准不要求关于该程序的实现。
【*注：* 在模板实参推导和替换过程中，其他上下文中要求诊断的某些构造被不同对待；参见[17.8.2](c17#s8.2)。*——注结束*】
^3^ 对于类和类模板，库章节指定部分定义。私有成员（第[14](c14)章）未指定，但每个实现应提供它们以根据库章节中的描述完成定义。
^4^ 对于函数、函数模板、对象和值，库章节规定声明。实现应提供与库章节中描述一致的定义。
^5^ 在库中定义的名称具有命名空间范围（[10.3](c10#s3)）。C++翻译单元（[5.2](c5#s2)）通过包含适当的标准库头文件（[19.2](c19#s2)）来获得对这些名称的访问。
^6^ 库中的模板、类、函数和对象具有外部链接（[6.5](c6#s5)）。必要时，实现提供标准库实体的定义，同时结合翻译单元以形成完整的C++程序（[5.2](c5#s2)）。
^7^ 实现有两种定义：*托管实现* 和 *独立实现*。对于托管实现，本国际标准定义了可用库的集合。独立实现是一种在没有操作系统的好处的情况下执行的方法，它有一个包含某些语言支持库（[20.5.1.3](c20#s5.1.3)）的实现定义的库的集合。
^8^ 一致的实现可以具有扩展（包括附加库函数），前提是它们不改变任何合法程序的行为。实现要求根据本国际标准诊断非法使用这种扩展的程序。然而，他们可以编译和执行这种程序。
^9^ 每个实现应包括文档，标识所有不支持的有条件支持的构造，并定义所有区域特定的特性。[^3]

[^2]: ~(2)~ “正确执行”可以包括未定义的行为，这取决于正在处理的数据；参见第[3](c3)章和第[4.6](#s6)节。
[^3]: ~(3)~ 本文档还定义了实现定义行为；参见第[4.6](#s6)节。

------------------------------------------------

## 4.2 文档结构 ![![intro.structure]!]! {#s2}
^1^ 第[5](c5)到[19](c19)章描述了C++编程语言。该描述包括详细语法规范，以第4.3节中描述的形式描述。为方便起见，附录A重复所有这种语法规范。
^2^ 第[21](c21)至[33](c33)章和附录[D](a3)（库章节）描述了C++标准库。该描述包括对构成库的实体和宏的详细描述，以第[20](c20)章中描述的形式描述。
^3^ 附录[B](a1)推荐一致性实现的容量下限。
^4^ 附录[C](a2)总结了C++第一次发的描述以来的演变，并详细解释了C++和C之间的区别。C++的某些特性仅为兼容性的目的而存在；附件[D](a3)描述了这些特性。
^5^ 在整个文档中，每个示例都由“【*例：*”引入，并由“*——例结束*】”终止。每个注释都由“【*注：*”引入，并由“*——注结束*】”终止。示例和注释可以嵌套。

------------------------------------------------

## 4.3 语法标记 ![![syntax]!]! {#s3}
^1^ 在本文档使用的语法标记中，语法类型由斜体类型和固定宽度类型的文字和字符表示。替代方案在单独的行中列出，除了少数情况下，一组较长的备选方案用短语“……中的一个”来标记。如果替代文本太长，无法在一行上拟合，则文本在第一个缩进的后续行上继续。可选的末端或非末端符号用下标“~可选~”表示，因此
`{`表达式~可选~`}`
表示一个可选的表达式，括在花括号内。
^2^ 语法类别的名称一般根据下列规则选择：
^(2.1)^ ——X名称是标识符在确定其含义的上下文中的使用（例如类名称、类型定义名称）。
^(2.2)^ ——X标识符是一个没有上下文相关含义的标识符（例如，限定标识符）。
^(2.3)^ ——X序列是一个或多个没有介入定界符的X（例如，声明序列是一个由声明组成的序列）。
^(2.4)^ ——X列表是由中间逗号分隔的一个或多个X（例如，标识符列表是由逗号分隔的标识符序列）。

------------------------------------------------

## 4.4 C++内存模型 ![![intro.memory]!]! {#s4}
^1^ C++内存模型中的基本存储单元是 *字节*。一个字节至少大到足以包含基本执行字符集（[5.3](c5#s3)）的任何成员和Unicode UTF-8编码格式的八位代码单元，并且由一个连续的位序列组成，[^4]其数目是实现定义的。最低有效位称为 *低阶位*，最高有效位称为 *高阶位*。C++程序可用的内存由一个或多个相邻字节序列组成。每个字节都有唯一的地址。
^2^ 【注：类型的表示在第[6.9](c6#s9)节中描述。——注结束】
^3^ *内存位置* 是标量类型的对象，或者是具有非零宽度的相邻位字段的最大序列。【注：语言的各种特性，如引用和虚拟函数，可能涉及到程序无法访问但由实现管理的附加内存位置。——注结束】两个或多个执行线程（[4.7](#s7)）可以在不干扰彼此的情况下访问单独的内存位置。
^4^ 【注：这样，位字段和相邻的非位字段位于单独的内存位置，因此可以由两个执行线程同时更新而不发生干扰。同样的情况适用于两个位字段，如果一个声明在嵌套结构声明中，另一个不是，或者如果这两个字段被零长度位字段声明分隔开，或者如果它们被非位字段声明分隔开。如果它们之间的所有字段也是非零宽度的位字段，则并发更新同一结构中的两个位字段是不安全的。——注结束】
^5^ 【例：声明如下结构
```cpp
struct {
  char a;
  int b:5,
  c:11,
  :0,
  d:8;
  struct {int ee:8;} e;
};
```
包含四个独立的内存位置：字段`a`与位字段`d`和`e.ee`是每个单独的存储器位置，并且可以同时修改而不相互干扰。位字段`b`和`c`一起构成第四个内存位置。位字段`b`和`c`不能同时修改，但例如`b`和`a`就可以。——例结束】

[^4]: ~(4)~ 字节中的位数由头文件`<climits>`中的宏`CHAR_BIT`报告。

------------------------------------------------

## 4.5 C++对象模型 ![![intro.object]!]! {#s5}
^1^ C++程序的构造创建、销毁、引用、访问并操纵对象。
