# 4 总则 ![![intro]!]! {#title}

本文为博主原创文章，未经博主允许不得转载。

------------------------------------------------

## 4.1 实现依从性 ![![intro.compliance]!]! {#s1}
^1^ *可诊断规则* 的集合由本标准中的所有句法和语义规则组成，包含明确标记的“不要求诊断”或描述为“未定义行为”的规则除外。
^2^ 虽然本国际标准只对C++实现提出了要求，但如果这些要求被表述为程序、程序片段或程序执行的要求，那么这些要求通常更容易理解。这种要求具有以下含义：
^(2.1)^ ——如果一个程序不违反本标准中的规则，一致的实现应在其资源范围内接受并正确执行[^2]该程序。
^(2.2)^ ——如果程序包含违反任何可诊断规则或在本标准中描述为“有条件支持”的构造发生，当实现不支持该构造时，一致的实现应发出至少一个诊断消息。
^(2.3)^ ——如果程序包含违反不要求诊断的规则，本国际标准不要求关于该程序的实现。
【*注：* 在模板实参推导和替换过程中，其他上下文中要求诊断的某些构造被不同对待；参见[17.8.2](c17#s8.2)。*——注结束*】
^3^ 对于类和类模板，库章节指定部分定义。私有成员（第[14](c14)章）未指定，但每个实现应提供它们以根据库章节中的描述完成定义。
^4^ 对于函数、函数模板、对象和值，库章节规定声明。实现应提供与库章节中描述一致的定义。
^5^ 在库中定义的名称具有命名空间范围（[10.3](c10#s3)）。C++翻译单元（[5.2](c5#s2)）通过包含适当的标准库头文件（[19.2](c19#s2)）来获得对这些名称的访问。
^6^ 库中的模板、类、函数和对象具有外部链接（[6.5](c6#s5)）。必要时，实现提供标准库实体的定义，同时结合翻译单元以形成完整的C++程序（[5.2](c5#s2)）。
^7^ 实现有两种定义：*托管实现* 和 *独立实现*。对于托管实现，本国际标准定义了可用库的集合。独立实现是一种在没有操作系统的好处的情况下执行的方法，它有一个包含某些语言支持库（[20.5.1.3](c20#s5.1.3)）的实现定义的库的集合。
^8^ 一致的实现可以具有扩展（包括附加库函数），前提是它们不改变任何合法程序的行为。实现要求根据本国际标准诊断非法使用这种扩展的程序。然而，他们可以编译和执行这种程序。
^9^ 每个实现应包括文档，标识所有不支持的有条件支持的构造，并定义所有区域特定的特性。[^3]

[^2]: ~(2)~ “正确执行”可以包括未定义的行为，这取决于正在处理的数据；参见第[3](c3)章和第[4.6](#s6)节。
[^3]: ~(3)~ 本文档还定义了实现定义行为；参见第[4.6](#s6)节。

------------------------------------------------

## 4.2 文档结构 ![![intro.structure]!]! {#s2}
^1^ 第[5](c5)到[19](c19)章描述了C++编程语言。该描述包括详细语法规范，以第4.3节中描述的形式描述。为方便起见，附录[A](a1)重复所有这种语法规范。
^2^ 第[21](c21)至[33](c33)章和附录[D](a4)（库章节）描述了C++标准库。该描述包括对构成库的实体和宏的详细描述，以第[20](c20)章中描述的形式描述。
^3^ 附录[B](a2)推荐一致性实现的容量下限。
^4^ 附录[C](a3)总结了C++第一次发的描述以来的演变，并详细解释了C++和C之间的区别。C++的某些特性仅为兼容性的目的而存在；附件[D](a3)描述了这些特性。
^5^ 在整个文档中，每个示例都由“【*例：*”引入，并由“*——例结束*】”终止。每个注释都由“【*注：*”引入，并由“*——注结束*】”终止。示例和注释可以嵌套。

------------------------------------------------

## 4.3 语法标记 ![![syntax]!]! {#s3}
^1^ 在本文档使用的语法标记中，语法类型由斜体类型和固定宽度类型的文字和字符表示。替代方案在单独的行中列出，除了少数情况下，一组较长的备选方案用短语“……中的一个”来标记。如果替代文本太长，无法在一行上拟合，则文本在第一个缩进的后续行上继续。可选的末端或非末端符号用下标“~可选~”表示，因此
`{`表达式~可选~`}`
表示一个可选的表达式，括在花括号内。
^2^ 语法类别的名称一般根据下列规则选择：
^(2.1)^ ——X名称是标识符在确定其含义的上下文中的使用（例如类名称、类型定义名称）。
^(2.2)^ ——X标识符是一个没有上下文相关含义的标识符（例如，限定标识符）。
^(2.3)^ ——X序列是一个或多个没有介入定界符的X（例如，声明序列是一个由声明组成的序列）。
^(2.4)^ ——X列表是由中间逗号分隔的一个或多个X（例如，标识符列表是由逗号分隔的标识符序列）。

------------------------------------------------

## 4.4 C++内存模型 ![![intro.memory]!]! {#s4}
^1^ C++内存模型中的基本存储单元是 *字节*。一个字节至少大到足以包含基本执行字符集（[5.3](c5#s3)）的任何成员和Unicode UTF-8编码格式的八位代码单元，并且由一个连续的位序列组成，[^4]其数目是实现定义的。最低有效位称为 *低阶位*，最高有效位称为 *高阶位*。C++程序可用的内存由一个或多个相邻字节序列组成。每个字节都有唯一的地址。
^2^ 【注：类型的表示在第[6.9](c6#s9)节中描述。——注结束】
^3^ *内存位置* 是标量类型的对象，或者是具有非零宽度的相邻位域的最大序列。【注：语言的各种特性，如引用和虚拟函数，可能涉及到程序无法访问但由实现管理的附加内存位置。——注结束】两个或多个执行线程（[4.7](#s7)）可以在不干扰彼此的情况下访问单独的内存位置。
^4^ 【*注：* 这样，位域和相邻的非位域位于单独的内存位置，因此可以由两个执行线程同时更新而不发生干扰。同样的情况适用于两个位域，如果一个声明在嵌套结构声明中，另一个不是，或者如果这两个字段被零长度位域声明分隔开，或者如果它们被非位域声明分隔开。如果它们之间的所有字段也是非零宽度的位域，则并发更新同一结构中的两个位域是不安全的。*——注结束*】
^5^ 【*例：* 声明如下结构
```cpp
struct {
  char a;
  int b:5,
  c:11,
  :0,
  d:8;
  struct {int ee:8;} e;
};
```
包含四个独立的内存位置：字段`a`与位域`d`和`e.ee`是每个单独的存储器位置，并且可以同时修改而不相互干扰。位域`b`和`c`一起构成第四个内存位置。位域`b`和`c`不能同时修改，但例如`b`和`a`就可以。*——例结束*】

[^4]: ~(4)~ 字节中的位数由头文件`<climits>`中的宏`CHAR_BIT`报告。

------------------------------------------------

## 4.5 C++对象模型 ![![intro.object]!]! {#s5}
^1^ C++程序的构造创建、销毁、引用、访问并操纵对象。当隐式地改变联合（第[12.3](c12#s3)节）的活动成员时，或者当创建临时对象（第[7.4](c7#s4)、[15.2](c15#s2)节）时，由定义（第[6.1](c6#s1)节）或new表达式（第[8.3.4](c8#s3.4)节）创建对象。对象在其构建周期（第[15.7](c15#s7)节）中占据一个存储区域，贯穿其一生（第[6.8](c6#s8)节），也在其销毁期间（第[15.7](c15#s7)节）。【*注：* 函数不是对象，不管它是否以对象的方式占用存储。*——注结束*】对象的属性是在创建对象时确定的。对象可以有名称（第[6](c6)章）。对象具有存储时间（第[6.7](c6#s7)节），影响其寿命（第[6.8](c6#s8)节）。对象具有类型（第[6.9](c6#s9)节）。某些对象是多态的（第[13.3](c13#s3)节）；实现生成与每个这样的对象相关联的信息，使得在程序执行期间确定对象的类型成为可能。对于其他对象，在其中找到的值的解释由用于访问它们的 *表达式*（第[8](c8)章）的类型确定。
^2^ 对象可以包含其他对象，称为 *子对象*。子对象可以是 *成员子对象*（第[12.2](c12#s2)节）、*基类子对象*（第[13](c13)章）或数组元素。不是任何其他对象子对象的对象称为 *完整对象*。如果对象在与成员子对象或数组元素 *e* 相关联的存储中创建（其可能或可能不在其生存期内），则创建的对象是包含对象的 *e* 的子对象，如果：
^(2.1)^ ——*e* 的包含对象的生命周期已经开始并没有结束，且
^(2.2)^ ——新对象的存储正好覆盖了与 *e* 相关的存储位置，且
^(2.3)^ ——新对象的类型与 *e* 相同（忽略cv限定符）。
【*注：* 如果子对象包含引用成员或常量子对象，则不能使用原始子对象的名称来访问新对象（第[6.8](c6#s8)节）。*——注结束*】【*例：*
```cpp
struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          // 很好，创建u的新子对象（第12.3节）
  X *p = new (&u.x) X {2};            // 很好，创建u的新子对象
  assert(p->n == 2);                  // 很好
  assert(*std::launder(&u.x.n) == 2); // 很好
  assert(u.x.n == 2);                 // 未定义行为，u.x不名为新的子对象
}
```
*——例结束*】
^3^ 如果一个完整对象在关联另一类型为“*N* 个`unsigned char`的数组”或“*N* 个`std::byte`的数组”（第[21.2.1](c21#s2.1)节）的对象 *e* 的存储中创建（第[8.3.4](c8#s3.4)节），则该数组为所创建的对象 *提供存储*，如果：
^(3.1)^ ——*e* 的生命已经开始并没有结束，且
^(3.2)^ ——新对象的存储完全适合 *e*，且
^(3.3)^ ——没有满足这些约束的更小数组对象。
【*注：* 如果数组的那个部分先前为另一个对象提供了存储，则该对象的生命周期结束，因为它的存储被重用（第[6.8](c6#s8)节）。*——注结束*】【*例：*
```cpp
template<typename ...T>
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion<int, char> au;
  int *p = new (au.data) int;     // 好的，au.data提供存储
  char *c = new (au.data) char(); // 好的，结束*p的生命期
  char *d = new (au.data + 1) char();
  return *c + *d; // 好的
}

struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
A a;
B *b = new (a.a + 8) B;      // a.a为*b提供存储
int *p = new (b->b + 4) int; // b->b为*p提供存储
                             // a.a不（直接）为*p提供存储，
                             // 但是*p嵌套在a中（见下）
```
*——例结束*】
^4^ 对象 *a 嵌套在* 另一个对象 *b 中*，如果：
^(4.1)^ ——*a* 是 *b* 的子对象，或
^(4.2)^ ——*b* 为 *a* 提供存储，或
^(4.3)^ ——存在一个对象 *c*，其中 *a* 嵌套在 *c* 中，*c* 嵌套在 *b* 中。
^5^ 对于每个对象`x`，有一个对象称为`x`*的完整对象*，确定方法如下：
^(5.1)^ ——如果`x`是一个完整对象，那么`x`的完整对象就是它自己。
^(5.2)^ ——否则，`x`的完整对象是包含`x`的（唯一）对象的完整对象。
^6^ 如果完整对象、数据成员（第[12.2](c12#s2)节）或数组元素是类类型的，则它的类型被认为是 *最深派生类*，以区别于任何基类子对象的类类型；最深派生类或非类类型的对象被称为 *最深派生对象*。
^7^ 除非它是位域（第[12.2.4](c12#s2.4)节），否则最深派生对象将具有非零大小，并将占用一个或多个字节的存储。基类子对象可以具有零大小。平凡可复制或标准布局类型（第[6.9](c6#s9)节）的对象将占用连续的字节存储。
^8^ 除非一个对象是一个位域或一个零大小的基类子对象，否则该对象的地址是它所占用的第一个字节的地址。两个具有重叠的生命期的非位域对象 *a* 和 *b* 可能具有相同的地址，如果一个嵌套在另一个中，或者如果至少一个是零大小的基类子对象，且它们是不同类型的；否则，它们具有不同的地址。[^5]
【*例：*
```cpp
static const char test1 = ’x’;
static const char test2 = ’x’;
const bool b = &test1 != &test2; // 总是true
```
*——例结束*】
^9^ 【*注：* C++提供了多种基本类型和几种从现有类型组成新类型的方法（第[6.9](c6#s9)节）。*——注结束*】

[^5]: ~(5)~ 在“似乎”规则下，如果程序不能观察到差异（第[4.6](#s6)节），则允许实现在同一个机器地址上存储两个对象或者根本不存储对象。

------------------------------------------------

## 4.6 程序执行 ![![intro.execution]!]! {#s6}
^1^ 本国际标准中的语义描述定义了一个参数化的非确定性抽象机器。本国际标准对一致性实现的结构没有任何要求。特别地，他们不需要复制或模仿抽象机器的结构。相反，需要一致的实现来（仅）模拟抽象机器的可观察行为，如下所述。[^6]
^2^ 抽象机器的某些方面和操作在本国际标准中描述为实现定义（例如`sizeof(int)`）。这些构成了抽象机器的参数。每一实现应包括描述其在这些方面的特征和行为的文档。[^7]此类文档应定义与该实现相对应的抽象机器实例（以下称为“对应实例”）。
^3^ 抽象机器的某些其他方面和操作在本国际标准中被描述为未明确的（例如，在 *new初始化器* 中对表达式进行评估，如果分配函数未能分配内存）。在可能的情况下，本国际标准定义了一组可允许的行为。这些定义了抽象机器的非确定性方面。因此，抽象机器的实例对于给定的程序和给定的输入可以有不止一种可能的执行。
^4^ 某些其他操作在本国际标准中被描述为未定义的（例如，试图修改`const`对象的效果）。【*注：* 本国际标准对包含未定义行为的程序的行为没有任何要求。*——注结束*】
^5^ 执行一个成形的程序的一致性实现将产生与同一程序和相同输入的抽象机器的相应实例的可能执行之一相同的可观察行为。然而，如果任何这样的执行包含未定义的操作，则本国际标准不要求执行具有该输入的程序（甚至不涉及第一未定义操作之前的操作）。
^6^ 具有自动存储持续时间（[6.7.3](c6#s7.3)）的每个对象实例与每个条目关联到其块中。这样的对象存在并且在块的执行期间保持其最后的存储值，且档块被暂停（通过函数的调用或信号的接收）时。
^7^ 一致性实施的最低要求是：
^(7.1)^ ——通过易变推广左值的访问严格按照抽象机器的规则进行评估。
^(7.2)^ ——在程序终止时，写入文件的所有数据应与根据抽象语义生成程序的可能结果之一相同。
^(7.3)^ ——交互设备的输入和输出动态应该以这样的方式发生，即在程序等待输入之前，实际上是提示输出先被传递。交互设备是由定义实现的。
这些统称为程序的 *可观察行为*。【*注：* 抽象和实际语义之间的更严格的对应关系可以由每个实现定义。*——注结束*】
^8^ 【*注：* 操作符可以根据通常的数学规则重新分组，仅当操作符真的是相关联的或可交换的。[^8]例如，在下面的片段中，
```cpp
int a, b;
/* ... */
a = a + 32760 + b + 5;
```
表达式语句的行为完全等同于
```cpp
a = (((a + 32760) + b) + 5);
```
，因为这些运算符的关联性和优先性。因此，将和`(a + 32760)`的结果接着加`b`，然后将结果加`5`，从而得到赋值给`a`的值。在溢出产生异常的机器中，且其中由`int`表示的值的范围是`[-32768，+32767]`，则实现不能将该表达式重写为
```cpp
a = ((a + b) + 32765);
```
，因为如果`a`和`b`的值，分别为`32754`和`15`，则和`a + b`会产生一个异常，而原始的表达不会；也不可以被重写为
```cpp
a = ((a + 32765) + b);
```
或
```cpp
a = (a + (b + 32765));
```
，因为`a`和`b`的值可能分别为`4`和`-8`或`-17`和`12`。然而，在溢出不产生异常且溢出结果是可逆的机器上，上述表达式语句可以通过上述方式中的任何一种实现重写，因为相同的结果将会发生。*——注结束*】
^9^ *成分表达式* 定义如下：
^(9.1)^ ——表达式的成分表达式是该表达式。
^(9.2)^ ——*花括号初始化列表* 或（可能带有括号的）*表达式列表* 的组成表达式是各自列表元素的成分表达式。
^(9.3)^ ——`=`*初始化子句* 形式的 *花括号或赋值初始化器* 的构成表达式是 *初始化子句* 的组成表达式。
【*例：*
```cpp
struct A { int x; };
struct B { int y; struct A a; };
B b = { 5, { 1+1 } };
```
用于初始化`b`的初始化器的组成表达式为`5`和`1 + 1`。*——例结束*】
^10^ 表达式`e`的 *直接子表达式* 是：
^(10.1)^ ——`e`的操作数的成分表达式（第[8](c8)章），
^(10.2)^ ——`e`隐式调用的任何函数调用，
^(10.3)^ ——如果`e`是 *lambda表达式*（第[8.1.5](c8#s1.5)节），由复制捕获的实体的初始化，和 *初始捕获* 的 *初始化器* 的成分表达式，
^(10.4)^ ——如果`e`是函数调用（第[8.2.2](c8#s2.2)节）或隐式调用函数，则是调用中使用的每个默认参数（第[11.3.6](c11#s3.6)节）的成分表达式，或
^(10.5)^ ——如果`e`创建聚合对象（第[11.1](c11#s1)节），则是初始化中使用的每个默认成员初始化器（第[12.2](c12#s2)节）的成分表达式。
^11^ 表达式`e`的子表达式是`e`的直接子表达式或`e`的直接子表达式的子表达式。【注：在lambda表达式的复合语句中出现的表达式不是lambda表达式的子表达式。——注结束】
^12^ 完整表达式是
^(12.1)^ ——未计算的操作量（第8章），
^(12.2)^ ——常量表达式（第8.20节），
^(12.3)^ ——初始化声明器（第11章）或成员初始化器（15.6.2），包括初始化器的成分表达式，
^(12.4)^ ——在对象生命期结束时生成的析构函数的调用，而不是临时对象（15.2），或
^(12.5)^ ——不是另一表达式子表达式的，且不是完全表达式的一部分的表达式。
如果定义语言构造定义为产生函数的隐式调用，则语言构造的使用被认为是用于此定义的表达式。应用于表达式的结果以满足表达式的语言构造的要求的转换也被认为是完整表达式的一部分。对于初始化器，执行实体的初始化（包括赋值集合的默认成员初始化器）也被认为是完整表达式的一部分。
【例：
```cpp
struct S {
  S(int i): I(i) { } // 完整表达式是I的初始化
  int& v() { return I; }
  ~S() noexcept(false) { }
private:
  int I;
};

S s1(1); // 完整表达式是S::S(int)的调用
void f() {
  S s2 = 2;     // 完整表达式是S::S(int)的调用
  if (S(3).v()) // 完整表达式包含左值到右值和
                // int到bool的转换，执行在
                // 临时对象在完整表达式结束时被删除前
  { }
  bool b = noexcept(S()); // S的析构函数的异常规范
                          // 被noexcept考虑
  // 完整表达式是s2在块末尾的析构
}
struct B {
  B(S = S(0));
};
B b[2] = { B(), B() }; // 完整表达式是整个初始化
                       // 包含临时对象的析构
```
——例结束】

[^6]: ~(6)~ 这一规定有时被称为“似乎”规则，因为一个实现可以自由地忽略本标准的任何要求，只要可以从程序的可观察行为中确定结果似乎符合要求。例如，实际的实现不需要评估表达式的一部分，如果它可以推断它的值不被使用，并且不会产生影响程序可观察行为的副作用。
[^7]: ~(7)~ 本文档还包括有条件支持的构造和区域特定行为。参见第[4.1](#s1)节。
[^8]: ~(8)~ 重载运算符从不假设为关联或可交换的。
